<html>
    <head>
        <title>Complexity</title>
        <link rel="stylesheet" type="text/css" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" />
        <link rel="stylesheet" href="style.css">
    </head>
    <body>
        <div class="topnav" style="padding-left: 3%;">
			<a href="banker.html"><b>Home</b></a>
			<a href="analysis.html"><b>Analysis</b></a>
			<a class="active" href="complexity.html"><b>Complexity</b></a>
            <a href="about.html"><b>About</b>
            </a>
        </div>    
        <img id="lOgo" src="IMAGES/5.png" alt="Analysis" style="padding-left: 35%;"> <hr>
        <div class="container">
            <div class="lead">
            Deadlock Avoidance, assuming that we are in a safe state and we are requested certain resources, simulates the allocation of those resources and determines if the resultant state is safe. If it is safe then request is satisfied, otherwise it is delayed until it becomes safe.<br />
            The Banker's Algorithm is used to determine if a request can be satisfied. It uses the following variables :<br />
            <br>
            <b>1. AVAILABLE </b>= &nbsp;it specifies for each resource how many copies of it are available. Let's take an array data structure to represent it. Hence We'll have Avail[1...m] of integers to represent AVAILABLE array where I assume that Each resource is named 1 \,\,to \,\,m$, Hence, Each Array index corresponds to one specific resource with same name as array index.<br />
            
            <br>
           <b> 2. ALLOCATION </b>= &nbsp;Array ALLOC[1..n, 1..m] of integer; -- ALLOC[i,j] specifies the number of copies of resource j that are allocated to process i. So, Rows represent Processes numbered from 1\,\,to\,\,n and columns represent Resources numbered from 1 \,\, to \,\,m<br />
            <br>

            <b>3. NEED</b>; array NEED[1..n, 1..m] of integer; -- NEED[i,j] specifies the number of copies of resource j that process i still requires. It is equal to MAX[i,j]-ALLOC[i,j]<br />
            Now let's analyze the time comp just like we apply Banker's algo to any problem.<br />
            So, First We Try to find that Process whose Need we can satisfy with the Available resources. Hence, We need to scan through All the Rows to NEED matrix to find such process which in worst case might take O(mn) time as we, in worst case, might have to scan all the n rows of NEED matrix with the AVAIL Array and in each row scan we have to compare m elements (of NEED of process P[i] and AVAIL array)..Hence O(mn)<br />
            After this, If we find such Row i.e. Process P[i] whose need we can satisfy then we allocate it its needed resources and let it complete. Which when completed, leaves all its resources it was previously holding(ALLOC matrix P [i] row) and these resources are added into the AVAIL array. This takes O(m) time as there are m resources. So, So far, For this First Process P[i] we have spent O(mn) + O(m) time. And Now it is out of our concern and so out of further consideration. <br />
            Then We move on to find next process P[j] whose request we can satisfy. And Same Procedure which we applied for Process P[i], is applied for it as well. i.e. We scan through each Row of NEED array and try to find such process P[j] whose NEED we can satisfy by comparing its NEED with the AVAIL array... Hence, In worst case, We might have to scan through all the (n-1) Rows of NEED array and for each Row, m comparisons with AVAIL array. Hence, Time taken O(m(n-1)).<br />
            <br>
            <b>4.</b> After finding such process, we allocate it its needed resources and let it complete. Which when completed, leaves all its resources it was previously holding(ALLOC matrix P[j] row) and these resources are added into the AVAIL array. This takes O(m) time as there are m resources. So, So far, For this Second Process P[j] we have spent O(m(n-1)) + O(m) time. And Now it is out of our concern and so out of further consideration. <br />
            Repeat this same procedure until All are completed or We can't find a safe sequence in between.
            <br />
           <b><i> So, Time comp in worst case = O(mn) + O(m(n-1)) + O(m(n-2)) + ..... + O(m) = O(m.n^2)</i></b></div>
            <hr>
           <div class="lead"><b>5.</b>  Complexity of Banker’s Algorithm is order O(m*n^2)<br />
            If there are n processes, then in the worst case the
            processes are ordered such that each iteration of the
            banker’s algorithm must evaluate all remaining
            processes before the last one satisfies<br />
            <br>
            <b>Needi ≤ Work</b><br />
            <br>
            • <b>1st time, n </b>processes have to compare if their Needi ≤ Work<br />
            • <b>2nd time, n-1 </b>processes have to be compared<br />
            •Thus, in the worst case, there are <b>n + (n-1) + (n-2) + ... + 2 + 1</b><br />
            <b> = n(n+1)/2</b> comparisons, which is proportional to <b> n^2 </b> complexity<br />
            •Each vector comparison requires m individual comparisons, since there are m resource types, so total complexity is <b>(m*n^2).</b> </div>
            </div>
        </div>   
        <br>
        <br>

        <img src="IMAGES/6.jpg" height="53px" width="100%">       
    </body>
</html>